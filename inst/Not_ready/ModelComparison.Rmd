---
title: "Model Comparison"
author: "James Smith"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{OM_Model}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  cache = TRUE
)
```

```{r message=FALSE, warning=FALSE}
library(WRAP)
```

Create a directory in your working directory for the simulations. Data and model outputs will be saved locally here

```{r}
dir.create(file.path(here::here(), 'Sim1'))
Sim1 <- ('Sim1/')
```

## Simulate data 

There are three simulation functions that can be used. `SimulatedWorld_ROMS()` which uses ROMS for the environmental fields, `SimulateWorld_ROMS_TrophicInteractins()` which uses ROMS and trophic interactions, and `SimulateWorld()` which simulates a temperature field.

We will use `SimulateWorld()` for this example. Type `?SimulateWorld` as console to learn more about this function.

Parameters for the functions. 

* `abund_enviro` can be "lnorm_low" (SB); "lnorm_high" (EW); or "poisson" (JS).
* `PA_shape` can be "logistic" (SB); "logistic_prev","linear" (JS)
* `temp_spatial` can be "simple" (SB); or "matern" (EW)
* `temp_diff` is only for the simulated temperature. It specifies min and max temps at year 1 and year 100 (e.g. temp_diff=c(1,3,5,7) means year 1 varies from 1-3C and year 100 from 5-7C). For non-ROMS data. 
* `dir` is the directory where ROMS data is stored. The ROMS functions are looking for a directory called `gfdl`. The default assumption is that this is in your working directory in a folder called `Rasters_2d_monthly`.

We will set the parameters so the following for our simulated abundances and presence/absence grid.

```{r}
abund_enviro <- "lnorm_low"
PA_shape <- "logistic"
temp_spatial <- "matern"
temp_diff <- c(1,4,3,7) 
```

Simulate species abundances from the simulated temperature fields.

```{r simworld, results='hide', message=FALSE}
sim1 <- SimulateWorld(temp_diff = temp_diff,  temp_spatial = temp_spatial, 
                      PA_shape = PA_shape, abund_enviro = abund_enviro) 
```

Printing the output will show you basic information about the simulation. This information is in `sim1$meta`.

```{r print_sim1}
sim1
```

Save data

```{r}
saveRDS(sim1, file=file.path(here(), "Sim1", "Sim1.rds"))
```

## Plot the simulated data

Create dataframe with historical/forecast data. The data frame with the abundances and presence/absence is in `grid` in the simulation object returned by the function.

```{r}
dat <- sim1$grid
dat_hist <- dat[dat$year<=2020,]
dat_fcast <- dat[dat$year>2020,]
```

Make some plots to explore the data. The simulated environmental covariate in `sim1` is `temp`.

```{r}
#All Years
par(mfrow=c(2,2))
plot(aggregate(suitability~year,dat,FUN="mean"),type="l", lwd=2, ylab="Suitability",col="dark grey")
lines(aggregate(suitability~year,dat[dat$year<=2020,],FUN="mean"),col="blue")
plot(aggregate(pres~year,dat,FUN="mean"),type="l", lwd=2,ylab="Presence",col="dark grey")
lines(aggregate(pres~year,dat[dat$year<=2020,],FUN="mean"),col="blue")
plot(aggregate(abundance~year,dat,FUN="sum"),type="l",  lwd=2,ylab="Abundance", col="dark grey")
lines(aggregate(abundance~year,dat[dat$year<=2020,],FUN="sum"),col="blue")
plot(aggregate(temp~year,dat,FUN="mean"),type="l",ylab="Temperature", col="dark grey")
```

## Fit SDMs to the simulated grid

We will fit GAM, BRT and MLP SDM models to the simulated grids. The fit function will fit the correct model based on the value of `abund_enviro`. If you want to restrict the smoothing, you can pass in `k` to the GAM function.

```{r fitmodels, results='hide', message=FALSE}
gam.p <- gam_sdm(sim1, covariates="temp", response="pres", start.forecast.year = 2020)
gam.a <- gam_sdm(sim1, covariates="temp", response="abundance", start.forecast.year = 2020)

brt.p <- brt_sdm(sim1, covariates="temp", response="pres", start.forecast.year = 2020)
brt.a <- brt_sdm(sim1, covariates="temp", response="abundance", start.forecast.year = 2020)

mlp.p <- mlp_sdm(sim1, covariates="temp", response="pres", start.forecast.year = 2020)
mlp.a <- mlp_sdm(sim1, covariates="temp", response="abundance", start.forecast.year = 2020)
```

## Example: Fit different model with `abund_enviro="poisson"`

We will compare `abund_enviro="poisson"` to `abund_enviro="lnorm_low"`. Everything else will be the same. We will compare GAMS, BRT, and MLP.

First create our new simulation:

```{r sim3, results='hide', message=FALSE}
sim3 <- SimulateWorld(temp_diff = temp_diff,  temp_spatial = temp_spatial, PA_shape = PA_shape, abund_enviro = "poisson") 
```

Now fit a GAM SDM to each simulated grid. Because `abund_enviro="poisson"`, a poisson model will be fit.

```{r}
gam.a.1 <- gam_sdm(sim3, covariates="temp", response="abundance", start.forecast.year = 2020)
gam.a.2 <- gam_sdm(sim3, covariates="temp", response="abundance", start.forecast.year = 2020, k=4)
```

New we want to fit the BRT and MLP SDMs.

```{r}
brt2.a <- brt_sdm(sim3, covariates="temp", response="abundance", start.forecast.year = 2020)
mlp2.a <- brt_sdm(sim3, covariates="temp", response="abundance", start.forecast.year = 2020)
```

### Poor thermal limit case

We will also do a fit where there is poor estimation of upper thermal limit.  To do this we will alter the data that the SDM is fit to. We do this by adding 5 percent extra rows as zeros (need a smart way to calculate penalty here; even very few data points can have big impact).

```{r}
dat_upper <- dat_hist[1:(nrow(dat_hist)*0.05),]  
dat_upper[] <- 0
dat_upper$temp <- 8  #estimated upper thermal limit
dat_upper$abundance <- 0  #all zeros
dat_hist2 <- rbind(dat_hist, dat_upper)
```

We can now fit to this new grid (data frame). We will restrict the smoothing with `k=4`.
```{r}
gam.a.3 <- gam_sdm(dat_hist2, covariates="temp", response="abundance", start.forecast.year = 2020, k=4)
```

## Plot of model comparisons

Set up the data for plotting.

```{r}
dat <- sim3$grid
dat_hist <- dat[dat$year<=2020,]
dat_fcast <- dat[dat$year>2020,]
```

Now plot the comparison of the models.

First we need to set up the temperatures used for prediction (forecast)
```{r}
new_dat <- data.frame(temp=seq(0,max(dat_hist$temp),length=100))
new_dat2 <- data.frame(temp=seq(0,7,length=100))
```

```{r}
par(mfrow=c(3,2), mar=c(3,4,4,2))
ylim2 <- 35

#actual TPC
xx <- seq(0, 7, length=100)
yy <- dnorm(xx, mean=4, sd=1)  #Must match function in SimulatedWorld function
plot(xx, yy, type="l", lty=2, main="Actual TPC", col="red", xlim=c(0,8), ylab="suitability", xlab="Temp")
xlim <- round(100*(max(dat_hist$temp)/7))
lines(xx[1:xlim], yy[1:xlim], lwd=2)

#gam Poisson
plot(new_dat2$temp, predict(gam.a.1, newdata=new_dat2, type="response"), type="l",
     main="Poisson GAM", xlim=c(0,8), col="red", lty=2, ylim=c(0,ylim2), ylab="Abundance", xlab="Temp")
points(dat_hist$temp, dat_hist$abundance, col="grey")
lines(new_dat$temp, predict(gam.a.1, newdata=new_dat, type="response"), lwd=2)

#gam Poisson with k=4
plot(new_dat2$temp, predict(gam.a.2, newdata=new_dat2, type="response"), type="l",
     main="Poisson GAM, k=4", xlim=c(0,8), col="red", lty=2, ylim=c(0,ylim2), ylab="Abundance", xlab="Temp")
points(dat_hist$temp, dat_hist$abundance, col="grey")
lines(new_dat$temp, predict(gam.a.2, newdata=new_dat, type="response"), lwd=2)

#gam 3 Poisson with k=4 and TL
plot(new_dat2$temp, predict(gam.a.3, newdata=new_dat2, type="response"), type="l",
     main="Poisson GAM, k=4, upperTL", xlim=c(0,8), col="red", lty=2, ylim=c(0,ylim2), ylab="Abundance", xlab="Temp")
points(dat_hist2$temp, dat_hist2$abundance, col="grey")
lines(new_dat$temp, predict(gam.a.3, newdata=new_dat, type="response"), lwd=2)

#BRT
plot(new_dat2$temp, predict(brt2.a, newdata=new_dat2, type="response",
     n.trees=brt2.a$gbm.call$best.trees), type="l",
     main="Poisson BRT", xlim=c(0,8), col="red", lty=2, 
     ylim=c(0,ylim2), ylab="Abundance", xlab="Temp")
points(dat_hist$temp, dat_hist$abundance, col="grey")
lines(new_dat$temp, predict(brt2.a, newdata=new_dat, type="response", n.trees=brt2.a$gbm.call$best.trees), lwd=2)

#MLP
dat_norm <- dat
dat_norm$temp_C <- dat_norm$temp
dat_norm$temp <- BBmisc::normalize(dat_norm$temp)
temp_mlp <- dat_norm[order(dat_norm$temp),]
temp_mlp_hist <- temp_mlp[temp_mlp$year <= 2020,]
plot(temp_mlp$temp_C, predict(mlp2.a, temp_mlp), type="l",
     main="Poisson MLP", xlim=c(0,8), col="red", lty=2, 
     ylim=c(0,ylim2), ylab="Abundance", xlab="Temp")
points(dat_hist$temp, dat_hist$abundance, col="grey")
lines(temp_mlp_hist$temp_C, predict(mlp2.a, temp_mlp_hist), lwd=2)
par(mfrow=c(1,1))
```

## Make Predictions for the future

The `predict(sim)` where `sim` is the output from one of the simulation functions (operating model) will return a list with three data frames. One for the hindcast, one for the forecast, and one ("pred") merged with a type column with "hindcast" and "forecast". Same shape as object$grid except the extra column in "pred". See `?predict.OM` for other arguments that this function takes.

You can pass in a previously fitted SDM to speed up the function. If you leave these off, predict will fit the SDM based on the value in `sim$meta$abund_enviro`. You can specify the SDM model.

```{r pred_om}
pred.gam <- predict(sim1, model="gam")
pred.brt <- predict(sim1, model="brt")
pred.mlp <- predict(sim1, model="mlp")
```

Assemble the predictions into one data frame.
```{r}
abund_enviro <- sim1$meta$abund_enviro
nr <- nrow(pred.gam)
dat_hist <- rbind(pred.gam$hindcast, pred.brt$hindcast, pred.mlp$hindcast)
dat_hist$model <- c(rep("gam", nr), rep("brt", nr), rep("mlp", nr))
dat_fcast <- rbind(pred.gam$forecast, pred.brt$forecast, pred.mlp$forecast)
dat_fcast$model <- c(rep("gam", nr), rep("brt", nr), rep("mlp", nr))
```

## Compare abundance predictons

```{r}
abund_enviro <- sim1$meta$abund_enviro

#Run if lognormal response was simulated
if (abund_enviro == "lnorm_low" | abund_enviro == "lnorm_high"){
  #Historical patterns
  plot(aggregate(abundance~year,dat_hist,FUN="sum"),type="l",  lwd=2,ylab="Abundance")
  lines(aggregate(gam1~year,dat_hist,FUN="sum"),type="l",  lwd=2,ylab="Abundance",col="blue")
  lines(aggregate(gam1.high~year,dat_hist,FUN="sum"),type="l",  lwd=2,ylab="Abundance",col="light blue")
  lines(aggregate(gam1.low~year,dat_hist,FUN="sum"),type="l",  lwd=2,ylab="Abundance",col="light blue")
  lines(aggregate(brt1~year,dat_hist,FUN="sum"),type="l",  lwd=2,ylab="Abundance",col="red")
  lines(aggregate(mlp1~year,dat_hist,FUN="sum"),type="l",  lwd=2,ylab="Abundance",col="green")
  legend("topright",c("Truth","GAM","BRT","MLP"),lty=1,col=c("black","blue","red", "green"),bty="n")
  
  #Future patterns
  plot(aggregate(abundance~year,dat_fcast,FUN="sum"),type="l",  lwd=2,ylab="Abundance")
  lines(aggregate(gam1~year,dat_fcast,FUN="sum"),type="l",  lwd=2,ylab="Abundance",col='blue')
  lines(aggregate(gam1.high~year,dat_fcast,FUN="sum"),type="l",  lwd=2,ylab="Abundance",col='light blue')
  lines(aggregate(gam1.low~year,dat_fcast,FUN="sum"),type="l",  lwd=2,ylab="Abundance",col='light blue')
  lines(aggregate(brt1~year,dat_fcast,FUN="sum"),type="l",  lwd=2,ylab="Abundance",col='red')
  lines(aggregate(mlp1~year,dat_fcast,FUN="sum"),type="l",  lwd=2,ylab="Abundance",col='green')
  legend("topright",c("Truth","GAM","BRT", "MLP"),lty=1,col=c("black","blue","red", "green"),bty="n")
}

#Run if poisson response was simulated
if (abund_enviro == "poisson"){
  #Historical patterns
  plot(aggregate(round(abundance)~year,dat_hist,FUN="sum"),type="l",  lwd=2,ylab="Abundance")
  lines(aggregate(gam2.a~year,dat_hist,FUN="sum"),type="l",  lwd=2,ylab="Abundance",col="blue")
  lines(aggregate(gam3.a~year,dat_hist,FUN="sum"),type="l",  lwd=2,ylab="Abundance",col="light blue")
  lines(aggregate(brt2.a~year,dat_hist,FUN="sum"),type="l",  lwd=2,ylab="Abundance",col="red")
  lines(aggregate(mlp2.a~year,dat_hist,FUN="sum"),type="l",  lwd=2,ylab="Abundance",col="green")
  legend("topright",c("Truth","GAM_normal","GAM_restricted","BRT","MLP"),lty=1,col=c("black","blue","light blue","red", "green"),bty="n")
  
  #Future patterns
  plot(aggregate(round(abundance)~year,dat_fcast,FUN="sum"),type="l",  lwd=2,ylab="Abundance",ylim=c(0,1700))
  lines(aggregate(gam2.a~year,dat_fcast,FUN="sum"),type="l",  lwd=2,ylab="Abundance",col='blue')
  lines(aggregate(gam3.a~year,dat_fcast,FUN="sum"),type="l",  lwd=2,ylab="Abundance",col='light blue')
  lines(aggregate(brt2.a~year,dat_fcast,FUN="sum"),type="l",  lwd=2,ylab="Abundance",col='red')
  lines(aggregate(mlp2.a~year,dat_fcast,FUN="sum"),type="l",  lwd=2,ylab="Abundance",col='green')
  legend("topright",c("Truth","GAM_normal","GAM_restricted","BRT","MLP"),lty=1,col=c("black","blue","light blue","red", "green"),bty="n")
}
```


#-----Calculate and plot centre of gravity-----

#Run if lognormal response was simulated
if (abund_enviro == "lnorm_low" | abund_enviro == "lnorm_high"){
  #Historical COG
  cog_hist_lat <- as.data.frame(matrix(NA,nrow=nrow(dat_hist),ncol=8))
  colnames(cog_hist_lat) <- c("year","truth","gam1","gam1.p","brt1","brt1.p","mlp1","mlp1.p")
  counter=1
  for (y in unique(dat_hist$year)){
    cog_hist_lat[counter,1] <- y
    cog_hist_lat[counter,2] <- weighted.mean(dat_hist$Lat[dat_hist$year==y],w=dat_hist$abundance[dat_hist$year==y])
    cog_hist_lat[counter,3] <- weighted.mean(dat_hist$Lat[dat_hist$year==y],w=dat_hist$gam1[dat_hist$year==y])
    cog_hist_lat[counter,4] <- weighted.mean(dat_hist$Lat[dat_hist$year==y],w=dat_hist$gam1.p[dat_hist$year==y])
    cog_hist_lat[counter,5] <- weighted.mean(dat_hist$Lat[dat_hist$year==y],w=dat_hist$brt1[dat_hist$year==y])
    cog_hist_lat[counter,6] <- weighted.mean(dat_hist$Lat[dat_hist$year==y],w=dat_hist$brt1.p[dat_hist$year==y])
    cog_hist_lat[counter,7] <- weighted.mean(dat_hist$Lat[dat_hist$year==y],w=dat_hist$mlp1[dat_hist$year==y])
    cog_hist_lat[counter,8] <- weighted.mean(dat_hist$Lat[dat_hist$year==y],w=dat_hist$mlp1.p[dat_hist$year==y])
    counter = counter + 1
  }
  head(cog_hist_lat)
  plot(cog_hist_lat$year,cog_hist_lat$truth, type='b')
  lines(cog_hist_lat$year,cog_hist_lat$gam1, type='b', col="blue")
  lines(cog_hist_lat$year,cog_hist_lat$brt1, type='b', col="red")
  lines(cog_hist_lat$year,cog_hist_lat$mlp1, type='b', col="green")
  
  #Future COG
  cog_fcast_lat <- as.data.frame(matrix(NA,nrow=nrow(dat_fcast),ncol=8))
  colnames(cog_fcast_lat) <- c("year","truth","gam1","gam1.p","brt1","brt1.p","mlp1","mlp1.p")
  counter=1
  for (y in unique(dat_fcast$year)){
    cog_fcast_lat[counter,1] <- y
    cog_fcast_lat[counter,2] <- weighted.mean(dat_fcast$Lat[dat_fcast$year==y],w=dat_fcast$abundance[dat_fcast$year==y])
    cog_fcast_lat[counter,3] <- weighted.mean(dat_fcast$Lat[dat_fcast$year==y],w=dat_fcast$gam1[dat_fcast$year==y])
    cog_fcast_lat[counter,4] <- weighted.mean(dat_fcast$Lat[dat_fcast$year==y],w=dat_fcast$gam1.p[dat_fcast$year==y])
    cog_fcast_lat[counter,5] <- weighted.mean(dat_fcast$Lat[dat_fcast$year==y],w=dat_fcast$brt1[dat_fcast$year==y])
    cog_fcast_lat[counter,6] <- weighted.mean(dat_fcast$Lat[dat_fcast$year==y],w=dat_fcast$brt1.p[dat_fcast$year==y])
    cog_fcast_lat[counter,7] <- weighted.mean(dat_fcast$Lat[dat_fcast$year==y],w=dat_fcast$mlp1[dat_fcast$year==y])
    cog_fcast_lat[counter,8] <- weighted.mean(dat_fcast$Lat[dat_fcast$year==y],w=dat_fcast$mlp1.p[dat_fcast$year==y])
    counter = counter + 1
  }
  head(cog_fcast_lat)
  plot(cog_fcast_lat$year,cog_fcast_lat$truth, type='b')
  lines(cog_fcast_lat$year,cog_fcast_lat$gam1, type='b', col="blue")
  lines(cog_fcast_lat$year,cog_fcast_lat$brt1, type='b', col="red")
  lines(cog_fcast_lat$year,cog_fcast_lat$mlp1, type='b', col="green")
}


#Run if poisson response was simulated
if (abund_enviro == "poisson"){
  #Historical COG
  cog_hist_lat <- as.data.frame(matrix(NA,nrow=20,ncol=6))
  colnames(cog_hist_lat) <- c("year","truth","gam2.a","gam3.a","brt2.a","mlp2.a")
  counter=1
  for (y in 2001:2020){
    cog_hist_lat[counter,1] <- y
    cog_hist_lat[counter,2] <- weighted.mean(dat_hist$Lat[dat_hist$year==y],w=dat_hist$abundance[dat_hist$year==y])
    cog_hist_lat[counter,3] <- weighted.mean(dat_hist$Lat[dat_hist$year==y],w=dat_hist$gam2.a[dat_hist$year==y])
    cog_hist_lat[counter,4] <- weighted.mean(dat_hist$Lat[dat_hist$year==y],w=dat_hist$gam3.a[dat_hist$year==y])
    cog_hist_lat[counter,5] <- weighted.mean(dat_hist$Lat[dat_hist$year==y],w=dat_hist$brt2.a[dat_hist$year==y])
    cog_hist_lat[counter,6] <- weighted.mean(dat_hist$Lat[dat_hist$year==y],w=dat_hist$mlp2.a[dat_hist$year==y])
    counter = counter + 1
  }
  head(cog_hist_lat)
  plot(cog_hist_lat$year,cog_hist_lat$truth, type='b')
  lines(cog_hist_lat$year,cog_hist_lat$gam2.a, type='b', col="blue")
  lines(cog_hist_lat$year,cog_hist_lat$brt2.a, type='b', col="red")
  lines(cog_hist_lat$year,cog_hist_lat$mlp2.a, type='b', col="green")
  
  #Future COG
  cog_fcast_lat <- as.data.frame(matrix(NA,nrow=80,ncol=6))
  colnames(cog_fcast_lat) <- c("year","truth","gam2.a","gam3.a","brt2.a","mlp2.a")
  counter=1
  for (y in 2021:2100){
    cog_fcast_lat[counter,1] <- y
    cog_fcast_lat[counter,2] <- weighted.mean(dat_fcast$Lat[dat_fcast$year==y],w=dat_fcast$abundance[dat_fcast$year==y])
    cog_fcast_lat[counter,3] <- weighted.mean(dat_fcast$Lat[dat_fcast$year==y],w=dat_fcast$gam2.a[dat_fcast$year==y])
    cog_fcast_lat[counter,4] <- weighted.mean(dat_fcast$Lat[dat_fcast$year==y],w=dat_fcast$gam3.a[dat_fcast$year==y])
    cog_fcast_lat[counter,5] <- weighted.mean(dat_fcast$Lat[dat_fcast$year==y],w=dat_fcast$brt2.a[dat_fcast$year==y])
    cog_fcast_lat[counter,6] <- weighted.mean(dat_fcast$Lat[dat_fcast$year==y],w=dat_fcast$mlp2.a[dat_fcast$year==y])
    counter = counter + 1
  }
  head(cog_fcast_lat)
  plot(cog_fcast_lat$year,cog_fcast_lat$truth, type='b')
  lines(cog_fcast_lat$year,cog_fcast_lat$gam2.a, type='b', col="blue")
  lines(cog_fcast_lat$year,cog_fcast_lat$brt3.a, type='b', col="red")
  lines(cog_fcast_lat$year,cog_fcast_lat$mlp2.a, type='b', col="green")
}
#-----Plot Surface Predictions-----
#Note these are point predictions for the ROMS data (not a prediction on the whole surface)
#Future
Y = 2021
#Truth
ggplot(dat_fcast[dat_fcast$year==Y,],aes(Lon,Lat))+
  geom_tile(aes(fill=abundance)) +
  theme_classic() +
  ggtitle("Truth")+
  labs(y="Latitude") +
  scale_x_continuous(expand = c(0, 0)) +
  scale_y_continuous( expand = c(0, 0)) +
  theme(legend.title=element_blank(),
        plot.title = element_text(hjust=0.5),
        # axis.text.x=element_blank(),
        # axis.ticks=element_blank(),
        # axis.title.x=element_blank(),
        panel.border = element_rect(colour = "black", fill=NA, size=1)) +
  scale_fill_viridis()

#Gam
ggplot(dat_fcast[dat_fcast$year==Y,],aes(Lon,Lat))+
  geom_tile(aes(fill=gam1)) +
  theme_classic() +
  ggtitle("GAM")+
  labs(y="Latitude") +
  scale_x_continuous(expand = c(0, 0)) +
  scale_y_continuous( expand = c(0, 0)) +
  theme(legend.title=element_blank(),
        plot.title = element_text(hjust=0.5),
        # axis.text.x=element_blank(),
        # axis.ticks=element_blank(),
        # axis.title.x=element_blank(),
        panel.border = element_rect(colour = "black", fill=NA, size=1)) +
  scale_fill_viridis()

#BRT
ggplot(dat_fcast[dat_fcast$year==Y,],aes(Lon,Lat))+
  geom_tile(aes(fill=brt1)) +
  theme_classic() +
  ggtitle("BRT")+
  labs(y="Latitude") +
  scale_x_continuous(expand = c(0, 0)) +
  scale_y_continuous( expand = c(0, 0)) +
  theme(legend.title=element_blank(),
        plot.title = element_text(hjust=0.5),
        # axis.text.x=element_blank(),
        # axis.ticks=element_blank(),
        # axis.title.x=element_blank(),
        panel.border = element_rect(colour = "black", fill=NA, size=1)) +
  scale_fill_viridis()

#MLP
ggplot(dat_fcast[dat_fcast$year==Y,],aes(Lon,Lat))+
  geom_tile(aes(fill=mlp1)) +
  theme_classic() +
  ggtitle("MLP")+
  labs(y="Latitude") +
  scale_x_continuous(expand = c(0, 0)) +
  scale_y_continuous( expand = c(0, 0)) +
  theme(legend.title=element_blank(),
        plot.title = element_text(hjust=0.5),
        # axis.text.x=element_blank(),
        # axis.ticks=element_blank(),
        # axis.title.x=element_blank(),
        panel.border = element_rect(colour = "black", fill=NA, size=1)) +
  scale_fill_viridis()



#----Optional: Sampling Program----
#Optional and up for discussion: subsetting data to simulation imperfect data collection
#JS: randomly subset the data - simulates ~imperfect data collection
# num_obs <- 500
# dat_histc <- dat_hist[sample(1:nrow(dat_hist), num_obs, replace=F),]

#SB: I'm not completely convinced we need to add another level of complexity here
#SB: I see value in testing the effect of different sampling programs, but might be outside the scope. 

